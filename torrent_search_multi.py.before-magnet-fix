#\!/usr/bin/env python3
"""
Multi-Indexer Torrent Search Script
Searches across all configured Jackett indexers using Torznab API
"""

import requests
import json
import base64
import sys
import re
import xml.etree.ElementTree as ET
from urllib.parse import quote_plus

# Configuration
JACKETT_API_KEY = "g0a8u9ri90ezjjw54grllpaflsgfgcnc"
JACKETT_URL = "http://192.168.2.2:9117"
TRANSMISSION_USER = "admin"
TRANSMISSION_PASS = "invent-creat3"
TRANSMISSION_URL = "http://192.168.2.2:9091/transmission/rpc"

# Available indexers
INDEXERS = [
    {"name": "1337x", "type": "general"},
    {"name": "eztv", "type": "tv"},
    {"name": "thepiratebay", "type": "general"},
    {"name": "therarbg", "type": "general"},
    {"name": "yts", "type": "movies"}
]

class Colors:
    RED = "\033[0;31m"
    GREEN = "\033[0;32m"
    YELLOW = "\033[1;33m"
    BLUE = "\033[0;34m"
    PURPLE = "\033[0;35m"
    CYAN = "\033[0;36m"
    NC = "\033[0m"

def format_size(size):
    """Format file size in human readable format"""
    try:
        size = int(size)
        if size >= 1073741824:
            return f"{size/1073741824:.1f} GB"
        elif size >= 1048576:
            return f"{size/1048576:.1f} MB"
        elif size >= 1024:
            return f"{size/1024:.1f} KB"
        else:
            return f"{size} B"
    except:
        return "Unknown"

def parse_torznab_response(xml_content):
    """Parse Torznab XML response into list of results"""
    results = []
    try:
        root = ET.fromstring(xml_content)
        
        # Find all item elements
        for item in root.findall('.//item'):
            result = {}
            
            # Extract basic fields
            title_elem = item.find('title')
            result['Title'] = title_elem.text if title_elem is not None else "Unknown"
            
            link_elem = item.find('link')
            result['Link'] = link_elem.text if link_elem is not None else ""
            
            size_elem = item.find('size')
            result['Size'] = int(size_elem.text) if size_elem is not None and size_elem.text else 0
            
            # Extract seeders and peers from torznab attributes
            result['Seeders'] = 0
            result['Peers'] = 0
            
            # Look for torznab attributes
            for attr in item.findall('.//{http://torznab.com/schemas/2015/feed}attr'):
                name = attr.get('name', '')
                value = attr.get('value', '0')
                if name == 'seeders':
                    try:
                        result['Seeders'] = int(value)
                    except:
                        result['Seeders'] = 0
                elif name == 'peers':
                    try:
                        result['Peers'] = int(value)
                    except:
                        result['Peers'] = 0
            
            # Extract tracker from jackettindexer
            indexer_elem = item.find('jackettindexer')
            result['Tracker'] = indexer_elem.text if indexer_elem is not None else "Unknown"
            
            results.append(result)
            
    except Exception as e:
        print(f"{Colors.RED}Error parsing XML: {e}{Colors.NC}")
    
    return results

def calculate_relevance_score(title, query_words):
    """Calculate relevance score based on how well title matches query"""
    title_lower = title.lower()
    score = 0
    
    # Check for exact phrase match (highest score)
    query_phrase = " ".join(query_words).lower()
    if query_phrase in title_lower:
        score += 100
    
    # Check for individual words with flexible matching
    for word in query_words:
        word_lower = word.lower()
        if len(word_lower) >= 3:  # Only check words 3+ characters
            # Exact word match (highest priority)
            pattern = r'\b' + re.escape(word_lower) + r'\b'
            if re.search(pattern, title_lower):
                score += 30
            # Partial match within word
            elif word_lower in title_lower:
                score += 15
    
    # Bonus if multiple words found
    words_found = sum(1 for word in query_words if len(word) >= 3 and word.lower() in title_lower)
    if words_found > 1:
        score += words_found * 10
    
    return score

def filter_results_by_relevance(results, query, min_score=15):
    """Filter and score results based on query relevance"""
    query_words = [w.strip() for w in query.strip().split() if len(w.strip()) >= 3]
    if not query_words:
        return results  # If no meaningful words, return all results
    
    scored_results = []
    for result in results:
        title = result.get("Title", "")
        score = calculate_relevance_score(title, query_words)
        
        if score >= min_score:
            result["relevance_score"] = score
            scored_results.append(result)
    
    # Sort by relevance score first, then by seeders
    scored_results.sort(key=lambda x: (x.get("relevance_score", 0), x.get("Seeders", 0)), reverse=True)
    
    return scored_results

def get_transmission_session():
    """Get Transmission session ID"""
    try:
        response = requests.get(TRANSMISSION_URL, auth=(TRANSMISSION_USER, TRANSMISSION_PASS))
        session_id = response.headers.get("X-Transmission-Session-Id")
        return session_id
    except:
        return None

def search_indexer(indexer_name, query, category=""):
    """Search a specific indexer using Torznab API"""
    # Construct URL for Torznab API
    url = f"{JACKETT_URL}/api/v2.0/indexers/{indexer_name}/results/torznab/api"
    params = {
        "apikey": JACKETT_API_KEY,
        "t": "search",
        "q": query
    }
    
    # Add category if specified
    if category:
        params["cat"] = category
    
    try:
        response = requests.get(url, params=params, timeout=15)
        if response.status_code == 200:
            return parse_torznab_response(response.content)
    except Exception as e:
        print(f"{Colors.RED}Error searching {indexer_name}: {e}{Colors.NC}")
    
    return []

def search_all_indexers(query, category_filter=None):
    """Search across all configured indexers"""
    print(f"{Colors.BLUE}Searching for: {Colors.YELLOW}{query}{Colors.NC}")
    print(f"{Colors.CYAN}Querying indexers...{Colors.NC}")
    
    all_results = []
    total_raw_results = 0
    
    for indexer in INDEXERS:
        # Skip indexer if category filter doesnt match
        if category_filter:
            if category_filter == "movie" and indexer["type"] not in ["general", "movies"]:
                continue
            if category_filter == "tv" and indexer["type"] not in ["general", "tv"]:
                continue
        
        print(f"  Searching {indexer['name']}...", end="", flush=True)
        
        results = search_indexer(indexer["name"], query)
        total_raw_results += len(results)
        
        if results:
            # Filter results by relevance
            filtered_results = filter_results_by_relevance(results, query)
            if filtered_results:
                print(f" {Colors.GREEN}✓ {len(filtered_results)}/{len(results)} relevant{Colors.NC}")
                all_results.extend(filtered_results)
            else:
                print(f" {Colors.YELLOW}✗ 0/{len(results)} relevant{Colors.NC}")
        else:
            print(f" {Colors.YELLOW}✗ No results{Colors.NC}")
    
    print(f"{Colors.CYAN}Total raw results: {total_raw_results}, Filtered to: {len(all_results)}{Colors.NC}")
    
    # Remove duplicates based on title
    seen_titles = set()
    unique_results = []
    for result in all_results:
        title = result.get("Title", "")
        if title not in seen_titles:
            seen_titles.add(title)
            unique_results.append(result)
    
    # Final sort by relevance score, then seeders
    unique_results.sort(key=lambda x: (x.get("relevance_score", 0), x.get("Seeders", 0)), reverse=True)
    
    return unique_results

def display_results(results, query):
    """Display search results"""
    if not results:
        print(f"\n{Colors.YELLOW}No relevant results found for \"{query}\"{Colors.NC}")
        return
    
    print(f"\n{Colors.GREEN}Found {len(results)} relevant results:{Colors.NC}\n")
    
    # Display first 30 results
    for i, result in enumerate(results[:30], 1):
        title = result.get("Title", "Unknown")
        size = result.get("Size", 0)
        seeders = result.get("Seeders", 0)
        peers = result.get("Peers", 0)
        tracker = result.get("Tracker", "Unknown")
        relevance = result.get("relevance_score", 0)
        
        size_str = format_size(size)
        
        # Color code by seeders
        if seeders > 20:
            seed_color = Colors.GREEN
        elif seeders > 5:
            seed_color = Colors.YELLOW
        else:
            seed_color = Colors.RED
        
        print(f"{i:2d}. {title[:70]}")
        print(f"    Size: {size_str:<12} Seeds: {seed_color}{seeders:<4}{Colors.NC} Peers: {peers:<4} Relevance: {relevance:<3} [{tracker}]")
        print()
    
    if len(results) > 30:
        print(f"{Colors.CYAN}(Showing first 30 of {len(results)} results){Colors.NC}\n")

def download_torrent(results, selection):
    """Download selected torrent to Transmission"""
    try:
        selection_idx = int(selection) - 1
        if selection_idx < 0 or selection_idx >= min(30, len(results)):
            print(f"{Colors.RED}Error: Invalid selection{Colors.NC}")
            return False
            
        selected_torrent = results[selection_idx]
        torrent_url = selected_torrent.get("Link", "")
        title = selected_torrent.get("Title", "Unknown")
        
        if not torrent_url:
            print(f"{Colors.RED}Error: No download link available{Colors.NC}")
            return False
            
        print(f"\n{Colors.CYAN}Downloading: {title[:70]}...{Colors.NC}")
        
        # Get session ID
        session_id = get_transmission_session()
        if not session_id:
            print(f"{Colors.RED}Error: Could not get Transmission session{Colors.NC}")
            return False
        
        # Download torrent file
        try:
            torrent_response = requests.get(torrent_url, timeout=30)
            torrent_response.raise_for_status()
            torrent_data = base64.b64encode(torrent_response.content).decode("utf-8")
        except Exception as e:
            print(f"{Colors.RED}Error: Failed to download torrent file - {e}{Colors.NC}")
            return False
        
        # Add to Transmission
        headers = {
            "X-Transmission-Session-Id": session_id,
            "Content-Type": "application/json"
        }
        
        request_data = {
            "method": "torrent-add",
            "arguments": {
                "metainfo": torrent_data
            }
        }
        
        try:
            response = requests.post(
                TRANSMISSION_URL,
                auth=(TRANSMISSION_USER, TRANSMISSION_PASS),
                headers=headers,
                json=request_data,
                timeout=30
            )
            response.raise_for_status()
            result = response.json()
            
            if result.get("result") == "success":
                print(f"{Colors.GREEN}✓ Torrent added to Transmission successfully\!{Colors.NC}")
                print(f"{Colors.BLUE}Check your downloads at: http://192.168.2.2:9091{Colors.NC}")
                return True
            else:
                error_msg = result.get("result", "Unknown error")
                print(f"{Colors.RED}Error: Failed to add torrent - {error_msg}{Colors.NC}")
                return False
                
        except Exception as e:
            print(f"{Colors.RED}Error: Failed to communicate with Transmission - {e}{Colors.NC}")
            return False
            
    except ValueError:
        print(f"{Colors.RED}Error: Please enter a valid number{Colors.NC}")
        return False

def main():
    """Main script logic"""
    print(f"{Colors.GREEN}=== Multi-Indexer Torrent Search Tool (Torznab) ==={Colors.NC}")
    print(f"{Colors.BLUE}Available indexers: 1337x, eztv, thepiratebay, therarbg, yts{Colors.NC}")
    print(f"{Colors.PURPLE}Using Torznab API with intelligent filtering\!{Colors.NC}")
    print()
    
    while True:
        print(f"{Colors.YELLOW}Options:{Colors.NC}")
        print("1. Search for torrents")
        print("2. Exit")
        print()
        
        try:
            choice = input("Choose an option (1-2): ").strip()
        except KeyboardInterrupt:
            print(f"\n{Colors.GREEN}Goodbye\!{Colors.NC}")
            sys.exit(0)
        
        if choice == "1":
            print()
            try:
                query = input("Enter search query: ").strip()
                if not query:
                    print(f"{Colors.RED}Error: Please enter a search query{Colors.NC}")
                    continue
                
                print()
                print(f"{Colors.YELLOW}Filter by category?{Colors.NC}")
                print("1. All categories")
                print("2. Movies only")
                print("3. TV Shows only")
                print()
                
                cat_choice = input("Choose category (1-3, default 1): ").strip()
                
                category_filter = None
                if cat_choice == "2":
                    category_filter = "movie"
                elif cat_choice == "3":
                    category_filter = "tv"
                
                print()
                results = search_all_indexers(query, category_filter)
                display_results(results, query)
                
                if results:
                    selection = input("Enter number to download (or press Enter to skip): ").strip()
                    
                    if selection:
                        download_torrent(results, selection)
                
                print()
                
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Search cancelled.{Colors.NC}")
                print()
                
        elif choice == "2":
            print(f"{Colors.GREEN}Goodbye\!{Colors.NC}")
            break
            
        else:
            print(f"{Colors.RED}Invalid option. Please choose 1-2.{Colors.NC}")
            print()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Colors.GREEN}Goodbye\!{Colors.NC}")
        sys.exit(0)
